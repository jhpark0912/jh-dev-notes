# Day 001. 왜 프로그래밍 언어는 0부터 셀까?

> 🗓️ 2026-02-24  
> 🏷️ Tags: `CS기초` `프로그래밍언어` `메모리`

---

## 🤔 질문

배열 인덱스는 왜 0부터 시작할까?  
일상에서 우리는 항상 1부터 세는데, 컴퓨터는 왜 다를까?

---

## 📌 핵심 요약

컴퓨터에서 인덱스는 **"몇 번째"가 아니라 "시작점에서 얼마나 떨어져 있는가(offset)"** 를 의미한다.  
첫 번째 요소는 시작점에서 0만큼 떨어져 있으므로 `[0]`이 자연스럽다.

---

## 🔍 자세히 들여다보기

### 1. 메모리 주소 계산과 오프셋

배열은 메모리 상에서 연속된 블록이다.

```
주소 계산: base + index × size
```

- `index = 0` → 첫 번째 요소는 `base + 0` = 바로 시작 주소
- 만약 1부터 시작하면 매번 `index - 1` 보정 연산이 필요해진다

이 차이가 CPU 레벨에서는 불필요한 연산을 줄여주는 의미가 있었다.

### 2. 다익스트라의 논증

1982년, 컴퓨터 과학자 **에츠허르 다익스트라(Edsger Dijkstra)** 는 범위 표현에 대한 짧은 메모를 남겼다.

- 반열린 구간 `[0, N)` 방식이 가장 깔끔하다
- 연속 구간을 이어붙일 때 경계가 자연스럽게 맞물린다
- 원소 개수 = `상한 - 하한`으로 바로 계산된다

### 3. 사람과 기계는 같은 숫자를 다른 의미로 쓴다

| 관점 | 질문 | 자연스러운 시작 |
|------|------|:---:|
| 사람 (순서, Ordinal) | "이게 몇 **번째**야?" | **1** |
| 기계 (거리, Displacement) | "시작점에서 얼마나 **떨어져** 있어?" | **0** |

같은 "세기"라는 행위지만, 서로 다른 질문에 답하고 있는 것이다.

---

## 🧭 언어별 설계 철학

| 구분 | 언어 예시 | 선택 이유 |
|------|-----------|-----------|
| **0-based** | C, Java, Python, JavaScript | 하드웨어 전통 계승, 오프셋 기반 |
| **1-based** | Lua, MATLAB, R, Julia | 사용자(수학자·과학자) 직관 우선 |

어느 쪽이 객관적으로 우월한 것이 아니라, **"누구의 관점에서 자연스러운가"** 를 설계자가 선택한 결과다.

---

## 💡 한 줄 정리

> 인덱스가 0부터 시작하는 이유는, 컴퓨터에게 인덱스란 "순서"가 아니라 **"오프셋"** 이기 때문이다.

---

## 📚 참고

- Dijkstra, E.W. (1982). *"Why numbering should start at zero"* — EWD831