# Day 003. 데이터 포맷의 역사와 Java 프레임워크 생태계

> 🗓️ 2026-02-26  
> 🏷️ Tags: `JSON` `XML` `YAML` `Spring` `SpringBoot` `Quarkus` `Micronaut`

---

## 🤔 질문

API 통신에서 왜 JSON을 쓸까? 예전에는 뭘 썼고, 앞으로는 뭘 쓸까?  
Spring의 XML 설정은 어떻게 사라졌고, Java 프레임워크 생태계는 지금 어떤 구도일까?

---

## 📌 핵심 요약

JSON은 **브라우저(소비자)가 포맷을 결정하고 서버(제공자)가 맞춰가는** 패턴으로 표준이 됐다.  
XML은 각 영역에서 더 적합한 대안(JSON, 어노테이션, YAML)에 의해 자연 도태되었으며,  
Java 프레임워크는 Spring Boot 중심으로 재편된 가운데 Quarkus, Micronaut이 도전 중이다.

---

## 🔍 Part 1. 데이터 포맷의 역사

### 1-1. JSON 이전의 세계: XML

2000년대 초반까지 데이터 교환의 표준은 **XML**이었다.

```xml
<user>
  <name>홍길동</name>
  <age>25</age>
  <skills>
    <skill>JavaScript</skill>
    <skill>Python</skill>
  </skills>
</user>
```

같은 데이터를 JSON으로 쓰면 훨씬 간결하다.

```json
{
  "name": "홍길동",
  "age": 25,
  "skills": ["JavaScript", "Python"]
}
```

XML은 모든 데이터에 여는 태그와 닫는 태그가 필요해서, 실제 데이터보다 태그가 차지하는 용량이 더 큰 경우도 흔했다.

---

### 1-2. JSON이 천하통일한 이유

단순히 가볍다는 것만으로는 부족했다. 핵심은 **JavaScript와의 궁합**이다.

JSON은 이름 자체가 "JavaScript Object Notation"으로, 브라우저에서 `JSON.parse()` 한 줄이면 바로 객체로 변환된다. XML은 별도의 파서로 DOM 트리를 만들고 거기서 값을 하나씩 꺼내야 했다.

2005년 이후 AJAX가 대중화되면서 브라우저에서 서버로 비동기 요청을 보내는 패턴이 폭발적으로 늘었고, 브라우저의 언어는 JavaScript밖에 없었으므로 JSON이 자연스럽게 선택됐다.

**"브라우저(소비자)가 포맷을 결정하고, 서버(제공자)가 맞춰간다"** — 이것이 JSON 확산의 핵심 역학이다.

---

### 1-3. 백엔드도 JSON을 환영한 이유

단순히 "어쩔 수 없이 따라간" 것은 아니다. 백엔드 개발자들도 XML에 지쳐 있었다.

XML 시절에는 **SOAP** 프로토콜을 사용했는데, 간단한 요청 하나에도 XML 봉투(envelope)를 싸고, 스키마를 정의하고, WSDL 명세서를 작성해야 했다.

```xml
<!-- SOAP: 이름 하나 조회하는데 이만큼 필요했다 -->
<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetUser xmlns="http://example.com">
      <UserId>123</UserId>
    </GetUser>
  </soap:Body>
</soap:Envelope>
```

```
// REST + JSON: 같은 일을 이렇게 끝낸다
GET /users/123
→ {"name": "홍길동", "age": 25}
```

**REST + JSON** 조합이 프론트와 백 양쪽 모두에서 환영받으며 빠르게 자리 잡았다.

---

### 1-4. JSON도 완벽하지 않다 — 바이너리 포맷의 등장

JSON의 한계: 주석을 넣을 수 없고, 날짜 타입이 없고, 텍스트 기반이라 대용량에서 용량이 크다.

**Protocol Buffers (protobuf)** — Google이 만든 바이너리 포맷. 스키마를 미리 정의하고 바이너리로 직렬화하여 JSON 대비 용량이 작고 파싱이 빠르다. gRPC와 함께 마이크로서비스 간 통신에서 많이 사용된다.

**MessagePack** — "바이너리 JSON"으로 불린다. JSON과 구조가 거의 같지만 바이너리라 더 작고 빠르며, 스키마 정의 없이 바로 쓸 수 있어 protobuf보다 진입 장벽이 낮다.

현실적으로는 이런 조합이 많다: **외부 API·프론트-백엔드 통신은 JSON, 내부 서비스 간 대용량 통신은 protobuf/MessagePack.**

---

### 1-5. 용도별 승자가 다르다

```
데이터 교환 (API 통신)
  XML + SOAP → JSON + REST → protobuf + gRPC (내부 통신)

애플리케이션 설정
  XML → 어노테이션 → Java Config → YAML (Spring Boot)

인프라/DevOps 설정
  XML → JSON → YAML (Docker, K8s, CI/CD)
```

XML이 사라진 건 맞지만, **JSON 때문이 아니라 각 영역에서 더 적합한 대안이 등장했기 때문**이다.

---

## 🔍 Part 2. Spring 생태계의 진화

### 2-1. Spring 설정의 변천사

**1세대: XML 지옥 (Spring 2.x~3.x)**

모든 Bean 등록을 XML로 했다. 프로젝트가 커지면 XML이 수천 줄이 되고, Bean 추가마다 XML을 수동 편집해야 했다.

```xml
<bean id="userService" class="com.example.UserService">
    <property name="userRepository" ref="userRepository"/>
</bean>
```

**2세대: 어노테이션 (Spring 3.x~)**

자바 코드 위에 직접 설정을 붙이는 방식이 도입됐다.

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

**3세대: Java Config (Spring 3.1~)**

자바 클래스로 설정을 작성. 컴파일 타임에 오류를 잡을 수 있다.

```java
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService(userRepository());
    }
}
```

**4세대: Spring Boot 자동 설정 (2014년~)**

`application.yml`에 최소한의 값만 넣으면 나머지는 Boot가 자동 구성한다.

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: 1234
```

설정 파일이 **JSON도 XML도 아닌 YAML**이 된 이유는, 사람이 자주 읽고 수정해야 하고, 주석을 달 수 있어야 하며, 계층 구조를 직관적으로 표현해야 하기 때문이다.

---

### 2-2. Spring의 XML은 지금 어떤 상태인가?

**"죽이지는 않지만 더 이상 키우지 않는"** 상태다.

- Spring 6.x: 핵심인 `<bean>` 네임스페이스는 deprecated가 아니며 정상 동작
- Spring 7.0: MVC XML 설정 네임스페이스(`<mvc:annotation-driven>` 등)가 deprecated 선언
- 완전 제거 계획은 없으나, XML 설정은 Java Config 모델을 따라 업데이트되지 않음

```
Spring의 XML 전략:

기존 XML 설정        → 계속 동작, 깨뜨리지 않음
새로운 기능          → Java Config / Boot 자동 설정으로만 제공
MVC XML 설정        → Spring 7.0에서 deprecated
<bean> 네임스페이스  → deprecated 아님, 당분간 유지
완전 제거            → 현재 계획 없음
```

전 세계 XML로 운영 중인 Spring 애플리케이션이 무수히 많기 때문에, **강제 제거가 아닌 자연 도태** 전략을 택한 것이다.

---

### 2-3. "큰 프로젝트는 순수 Spring" 공식은 사라졌다

Spring Boot 초기(2014년)에는 "간단한 프로젝트용"이라는 인식이 있었으나, 현재는 완전히 뒤집혔다.

2025년, Spring 생태계는 세대 전환을 이뤘다. Spring Framework 7, Spring Security 7, Spring Boot 4가 출시되었고, Spring Boot 자체를 의존성으로 가져가는 "post-Boot" 프로젝트가 등장했다.

Spring Boot가 규모 무관 표준이 된 이유:

- **엔터프라이즈급으로 성숙** — 초기의 "간단한 프로젝트용" 인식과 달리 안정성과 혁신의 균형 확보
- **순수 Spring만 쓸 이유 소멸** — 자동 설정이 마음에 안 들면 얼마든지 오버라이드 가능
- **생태계 자체가 Boot 중심으로 재편** — 공식 프로젝트 생성 도구(Spring Initializr)도 Boot 프로젝트만 생성

```java
// Spring Boot를 쓰면서도 특정 설정만 직접 제어 가능
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MyApp {
    @Bean
    public DataSource dataSource() {
        // 커스텀 설정
    }
}
```

```
예전 (2014~2018):
  작은 프로젝트 → Spring Boot
  큰 프로젝트  → 순수 Spring

지금 (2024~):
  신규 프로젝트 (규모 무관) → Spring Boot
  기존 레거시 유지보수       → 순수 Spring (마이그레이션 비용 때문에 유지)
```

---

## 🔍 Part 3. Java 프레임워크 생태계 — 새로운 도전자들

### 3-1. 왜 새로운 프레임워크가 등장했나?

Spring은 2003년에 설계되었다. 당시는 서버 한 대에 앱 하나를 올려서 오래 띄워두는 환경이었기에, 시작이 좀 느려도 한 번 뜨면 잘 돌아가면 됐다.

클라우드 시대가 오면서 상황이 바뀌었다. 컨테이너가 수시로 생겼다 사라지고, 서버리스(AWS Lambda)는 요청이 올 때만 앱을 띄워야 한다. 이 환경에서 **시작 속도와 메모리 사용량이 곧 비용**이다.

---

### 3-2. Quarkus — "클라우드를 위해 태어난 Java"

Red Hat이 개발. 클라우드 네이티브 시대를 위해 Java를 근본적으로 재설계한 프레임워크.

핵심 아이디어: **"런타임에 할 일을 빌드 타임으로 옮기자"**

Spring Boot는 앱이 시작될 때 클래스패스 스캔, Bean 탐색, 의존성 주입을 수행한다. Quarkus는 이 대부분을 **빌드(컴파일) 시점에 미리 처리**하여 시작 시간을 극적으로 줄인다.

```
Spring Boot: 앱 시작 → 스캔 → Bean 탐색 → DI → 설정 → 준비 완료 (느림)
Quarkus:     빌드 시 다 완료 → 앱 시작 → 로드만 → 준비 완료 (빠름)
```

---

### 3-3. Micronaut — "리플렉션을 없앤 Java"

OCI(Object Computing)가 개발. 컴파일 타임 의존성 주입과 AOT 컴파일에 집중.

**리플렉션(Reflection)** 이란 Spring이 `@Autowired`를 보고 실행 중에 클래스 정보를 뒤져서 주입 대상을 알아내는 기법이다. 편리하지만 느리고 메모리를 많이 소비한다.

Micronaut은 이를 **컴파일 시점에** 모두 결정하여 런타임 리플렉션을 제거했다.

---

### 3-4. 세 프레임워크 비유

```
Spring Boot  = 풀서비스 호텔
               체크인(시작)은 느리지만 모든 편의시설이 갖춰져 있음
               오래 묵을수록 만족도 높음

Quarkus      = 스마트 호텔
               체크인이 거의 즉시, 방도 충분히 좋음
               자주 체크인/체크아웃하는 사람(컨테이너, 서버리스)에게 최적

Micronaut    = 미니멀 부티크 호텔
               작고 가볍지만 필요한 건 다 있음
               IoT, 임베디드 등 자원이 제한된 환경에 강함
```

---

### 3-5. 성능 비교

**시작 시간 (REST API 기준)**

| 모드 | Spring Boot | Quarkus | Micronaut |
|------|:-----------:|:-------:|:---------:|
| JVM | 1.91초 | 1.15초 | 0.66초 |
| Native (GraalVM) | 0.104초 | 0.049초 | 0.050초 |

**Native 힙 메모리 사용량**

| Spring Boot | Quarkus | Micronaut |
|:-----------:|:-------:|:---------:|
| 11.0 MB | 3.2 MB | 5.1 MB |

시작 속도와 메모리에서는 Quarkus/Micronaut이 우세하지만, **지속적 부하 상태에서의 처리량(throughput)은 세 프레임워크 모두 비슷한 수준**이다. 자주 껐다 켜는 환경(서버리스)에서 차이가 크고, 한 번 띄워두는 환경에서는 차이가 적다.

Spring Boot도 가만히 있지 않았다. GraalVM 네이티브 이미지를 지원하여 시작 시간과 메모리 사용량을 크게 줄일 수 있게 됐다.

---

### 3-6. 인기도·채용 시장 비교

**Google Trends (검색량, 상대 지수)**

| 프레임워크 | 트렌드 | 비고 |
|-----------|--------|------|
| Spring Boot | 75 (소폭 하락세) | 2020년 정점(100) 이후 하락했으나 압도적 1위 |
| Quarkus | 45 (상승세) | 꾸준히 상승, 최근 역대 최고점 경신 |
| Micronaut | 7 (정체) | 2022년 정점 이후 소폭 하락, 니치 포지션 |

Spring Boot는 Quarkus 대비 약 **15배**의 검색량 차이를 보인다.

**채용 시장 (Indeed 구인 공고)**

Spring Boot가 압도적 1위이며, Quarkus와 Micronaut은 아직 한 자릿수 비중이다.  
"Spring Boot를 배우면 취업 시장에서 가장 넓은 선택지를 갖는다"는 의미.

**Stack Overflow 질문 수**

Spring Boot 200K+ / Quarkus 12K+ / Micronaut 4K+

---

### 3-7. 종합 비교

| 항목 | Spring Boot | Quarkus | Micronaut |
|------|:-----------:|:-------:|:---------:|
| 생태계 성숙도 | ★★★★★ | ★★★ | ★★ |
| 시작 속도 | ★★ | ★★★★★ | ★★★★★ |
| 메모리 효율 | ★★ | ★★★★★ | ★★★★ |
| 커뮤니티 규모 | ★★★★★ | ★★ | ★ |
| 클라우드 네이티브 | ★★★ | ★★★★★ | ★★★★ |
| 학습 자료 | ★★★★★ | ★★★ | ★★ |

```
현재 Java 백엔드 프레임워크 구도:

Spring Boot → 엔터프라이즈 표준, 가장 넓은 생태계, 채용 시장 지배
Quarkus     → 클라우드 네이티브 특화, Red Hat 지원, 빠르게 성장 중
Micronaut   → 컴파일 타임 DI, 낮은 메모리, IoT/서버리스 니치
```

---

## 💡 한 줄 정리

> **데이터 포맷은 소비자가 결정하고, 프레임워크는 시대가 결정한다.**  
> JSON은 브라우저가 이끌었고, Spring Boot는 엔터프라이즈가 선택했고, Quarkus/Micronaut은 클라우드가 불러냈다.

---

## 📚 참고

- [Google Trends: Spring Boot vs Quarkus vs Micronaut](https://trends.google.com/trends/explore?q=spring+boot,quarkus,micronaut)
- [Java Tech Popularity Index Q1/2024](https://betterprojectsfaster.com/guide/java-tech-popularity-index-2024-q1/be/)
- [Java Code Geeks: Framework Benchmark 2026](https://www.javacodegeeks.com/2025/12/spring-boot-vs-quarkus-vs-micronaut-the-ultimate-2026-showdown.html)
- [Spring Framework 7.0 Release Notes](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes)
- [Spring Framework Issue #34063 - MVC XML Deprecation](https://github.com/spring-projects/spring-framework/issues/34063)